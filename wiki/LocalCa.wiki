#labels Java, SSL, keytool, KeyStore, TrustManager

<h4>Overview</h4>

We consider innumerable clients connecting to a Java server over SSL sockets. 

Naturally, we generate certificates for each client, and typically import these self-signed certificates into our server truststore.

In this article, we sign client certificates using our server certificate as a local root CA certificate. As such, our server should support certificate revocation.

<h4>Certificate chain</h4>

Naturally an <tt>SSLServerSocket</tt> is created using an <tt>SSLContext</tt>, which is configured with a keystore and a truststore, as in the following example.

{{{
public class LocalCaTest {
    ...
    static void acceptSingle(KeyStore keyStore, char[] keyPassword, KeyStore trustStore,
            int port) throws GeneralSecurityException, IOException {
        SSLContext sslContext = SSLContexts.create(keyStore, keyPassword, trustStore);
        sslContext.init(keyManagerFactory.getKeyManagers(),
                trustManagerFactory.getTrustManagers(), new SecureRandom());
        SSLServerSocket serverSocket = (SSLServerSocket) sslContext.
                getServerSocketFactory().createServerSocket(port);
        try {
            serverSocket.setNeedClientAuth(true);
            handle(serverSocket.accept());
        } finally {
            serverSocket.close();
        }
    }    
}
}}}
where we create an SSL context and server socket, and accept a client connection. Our <tt>SSLContexts</tt> factory utility will be presented further below.

The keystore must contain our asymmetric private key, which is paired with its public key certificate. Moreover, it must contain the entire certificate chain of that key certificate right through to its root certificate. We list the certicate chain as follows.
{{{
$ keytool -keystore server.jks -alias server -list -v

Certificate chain length: 2

Certificate[1]:
Owner: CN=server
Issuer: CN=ca

Certificate[2]:
Owner: CN=ca
Issuer: CN=ca
}}}
where we have signed our server cert with a local CA cert, which is by definition the self-signed root of our certificate chain.

The server truststore contains trusted certificates to authenticate the client key certificate chain. 
{{{
$ keytool -keystore server.trust.jks -list 

Your keystore contains 1 entry

server, trustedCertEntry
}}}
where our client certificates will be signed by the server certificate, and so it can be our sole trusted cert. Notice that the certificate chain of this trusted certificate is not installed in the truststore.

<h4>openssl</h4>

We can use <tt>openssl</tt> to connect to the <tt>SSLServerSocket</tt> and inspect its key certificate chain as follows.
{{{
$ openssl s_client -connect localhost:4444

Certificate chain
 0 s:/CN=server
   i:/CN=ca
 1 s:/CN=ca
   i:/CN=ca

Acceptable client certificate CA names
/CN=server
}}}
where the subject and issuer of the two certificates in our key certificate chain are listed, and it will accept client certificates whose chain includes the server certificate e.g. as a parent certificate.

This demonstrates why the keystore requires a certificate chain, i.e. to send to the peer for authentication. The peer receives the chain, and authenticates it, stopping as soon as it encounters a certificate that it trusts. Therefore the chain for a trusted cert need not be stored in the truststore, and actually must not be, otherwise we trust <i>any</i> children of the trusted cert's root. 

<h4>Serial numbers</h4>

Incidently, <a href="http://www.docjar.org/html/api/sun/security/tools/KeyTool.java.html"><tt>!KeyTool.java</tt></a>, as used by the <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html"><tt>keytool</tt></a> command-line utility, generates a random serial number as follows.
{{{
        info.set(X509CertInfo.SERIAL_NUMBER, new CertificateSerialNumber(
            new java.util.Random().nextInt() & 0x7fffffff));
}}}

In a later article, we might build a local CA management tool, which might use a sequence number for client certs which it generates programmatically and records them into an SQL database.


<h4>SSLContexts</h4>

Ordinarily we create an <tt>SSLContext</tt> as follows.
{{{
public class SSLContexts {
    ...
    public static SSLContext create(KeyStore keyStore, char[] keyPassword,
            KeyStore trustStore) throws Exception {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPassword);
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance("SunX509");
        trustManagerFactory.init(trustStore);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(keyManagerFactory.getKeyManagers(),
                trustManagerFactory.getTrustManagers(), new SecureRandom());
        return sslContext;
    }
}
}}}

Since we wish to support a local CA, we should enable local certificate revocation in order to retain access control. We see that <tt><a href="http://www.docjar.org/html/api/java/security/cert/X509Certificate.java.html">!X509Certificate</a></tt> returns a <tt>!BigInteger</tt> for the serial number, that should be unique. Incidently, this is implemented by <a href="http://www.docjar.org/html/api/sun/security/x509/X509CertImpl.java.html"><tt>!X509CertImpl</tt></a>.

So we create an <tt>SSLContext</tt> with a set of revoked certificate serial numbers, as follows.
{{{
public class RevocableSSLContexts {
    ...
    public static SSLContext create(KeyStore keyStore, char[] keyPass,
            KeyStore trustStore, Set<BigInteger> revokedSerialNumbers) throws Exception {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPass);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        TrustManager revocableTrustManager = new RevocableTrustManager(
                getPrivateKeyCertificate(keyStore),
                getX509TrustManager(trustStore),
                revokedList);
        sslContext.init(keyManagerFactory.getKeyManagers(),
                new TrustManager[]{revocableTrustManager},
                new SecureRandom());
        return sslContext;
    }
}
}}}
where we initialise a custom <tt>!RevocableTrustManager</tt> with our server cert, and a set of revoked certificates' serial numbers.
{{{
public class RevocableTrustManager implements X509TrustManager {
    X509Certificate serverCertificate;
    X509TrustManager delegate;
    Set<BigInteger> revokedSerialNumbers;
    ...
    @Override
    public void checkClientTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        if (!certs[0].getSubjectX500Principal().equals(
                serverCertificate.getSubjectX500Principal())) {
            throw new CertificateException("Server cert used as client cert");
        }
        if (!certs[0].getIssuerX500Principal().equals(
                serverCertificate.getSubjectX500Principal())) {
            throw new CertificateException("Untrusted issuer");
        }
        if (!Arrays.equals(certs[1].getPublicKey().getEncoded(),
                serverCertificate.getPublicKey().getEncoded())) {
            throw new CertificateException("Invalid server certificate");
        }
        if (revokedSerialNumbers.contains(certs[0].getSerialNumber())) {
            throw new CertificateException("Certificate serial number revoked");
        }
        delegate.checkClientTrusted(certs, authType);
    }
}
}}}
where we check that the client certificate is signed by our server certificate, and not revoked. Finally, we delegate to the standard <tt>!X509TrustManager</tt> for good measure.

Notice that we do not accept the server cert as a client cert. This is a precaution in case our server keystore has been compromised, and a rogue is using it to connect to our server.

<h4>Revoked certificates</h4>

The set of revoked certificates' identifiers might be read from a file or a database. This could be a <tt>synchronized</tt> <tt>Set</tt> that can be updated concurrently, and so enables a dynamic truststore, which we test as follows.
{{{
    private void testDynamicRevocation(KeyStore serverKeyStore, KeyStore serverTrustStore,
            KeyStore clientKeyStore, KeyStore clientTrustStore, 
            int serialNumber) throws Exception {
        Set<BigInteger> revokedSerialNumbers = new ConcurrentSkipListSet();
        SSLContext serverSSLContext = RevocableSSLContexts.createRevokedSerialNumbers(
                serverKeyStore, pass, serverTrustStore, revokedSerialNumbers);
        SSLContext clientSSLContext = SSLContexts.create(clientKeyStore, pass, clientTrustStore);
        ServerThread serverThread = new ServerThread();
        try {
            serverThread.start(serverSSLContext, port, 2);
            Assert.assertEquals("", ClientThread.connect(clientSSLContext, port));
            Assert.assertEquals("", serverThread.getErrorMessage());
            revokedSerialNumbers.add(BigInteger.valueOf(serialNumber));
            clientSSLContext = SSLContexts.create(clientKeyStore, pass, clientTrustStore);
            ClientThread.connect(clientSSLContext, port);
            Assert.assertTrue(serverThread.getErrorMessage().
                    contains("Certificate serial number revoked"));
        } finally {
            serverThread.close();
        }
    }
}}}
where we create a concurrent <tt>Set</tt> for the revoked certificates, and revoke a client certificate after the server has been started. Before the certificate is revoked, the connection should succeed, and afterwards it should fail. 

Incidently, we find that the client session is cached for the SSL context, and so we recreate the <tt>clientSSLContext</tt> instance in our test above. This forces re-authentication by the server, so our trust manager is actually invoked and so our newly revoked certificate is rejected. Perhaps the reader can advise how to disable this client session caching for our unit test?

We connect to the server socket as follows.
{{{
    static String connect(SSLContext context, int port) 
            throws GeneralSecurityException, IOException {
        SSLSocket socket = (SSLSocket) context.getSocketFactory().
                createSocket(HOST, port);
        try {
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            dos.writeUTF("clienthello");
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            Assert.assertEquals("serverhello", dis.readUTF());
            logger.info("ok");
            return "";
        } catch (Exception e) {
            logger.info(e.getMessage());
            return e.getMessage();
        } finally {
            socket.close();
        }
    }
}}}
where we return any error message, or otherwise an empty string which indicates success. This avoids having to check for <tt>null</tt> when we expect an error message. 


<h4><tt>keytool</tt></h4>

Naturally we use <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html"><tt>keytool</tt></a> to create our keystores and truststores. For example, we create a private SSL keystore for a client, say evanx, as follows.
{{{
$ keytool -keystore evanx.jks -genkeypair -keyalg rsa -keysize 2048 -validity 365 -alias evanx \
    -dname "CN=evanx"
}}}
where we specify a validity period of 365 days.
 
We export our certificate as follows.
{{{
$ keytool -keystore evanx.jks -alias evanx -exportcert -rfc
}}}
We cut and paste the exported PEM text into a file, which we can inspect using <tt>openssl</tt> as follows.
{{{
$ openssl x509 -text -in evanx.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1380030508 (0x5241982c)
    Signature Algorithm: sha1WithRSAEncryption
        Issuer: CN=evanx
        Validity
            Not Before: Sep 24 13:48:28 2013 GMT
            Not After : Sep 24 13:48:28 2014 GMT
        Subject: CN=evanx
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
}}}
We import the client cert into the server SSL truststore.
{{{
$ keytool -keystore server.trust.jks -alias evanx -importcert -file evanx.pem
}}}
Similarly, the server cert is imported into the clients' truststores.

Incidently, in a follow-up article we will create keystores programmatically for our unit tests, taking cues from <a href="http://www.docjar.org/html/api/sun/security/tools/KeyTool.java.html"><tt>!KeyTool</tt></a>, and emulating the manual procedure.

<h4>Client certificate signing</h4>

Alternatively, we might export a certificate signing request (CSR) as follows, and sign this with the server cert. In this case our server is a local CA where we will trust any of its issued certificates. So we must support certificate revocation to control access.
{{{
$ keytool -keystore evanx.jks -alias evanx -certreq
}}}
We cut and paste the output PEM text into a CSR file, and use Java7's keytool to sign this CSR, using its new <tt>-gencert</tt> option, which by the way is not available in earlier JRE's.
{{{
$ keytool -keystore server.jks -gencert -validity 365 -rfc \
    -dname "CN=evanx" -infile evanx.csr -outfile evanx.signed.pem
}}}
where we specify an unchanged DN and validity period for the newly signed certificate.

We can inspect the cert using <tt>openssl</tt>.
{{{
$ openssl x509 -text -in evanx.signed.pem | grep CN
        Issuer: CN=server
        Subject: CN=evanx
}}}

Since the keystore requires its key certificate chain to be imported in the correct order starting with the root cert, we import the server cert first, and then our signed cert.
{{{
$ keytool -keystore evanx.jks -importcert -noprompt \
    -file server.pem -alias server 
Enter keystore password: 
Certificate was added to keystore

$ keytool -keystore evanx.jks -importcert -noprompt \
    -file evanx.signed.pem -alias evanx
Enter keystore password: 
Certificate reply was installed in keystore
}}}

In this case, our client keystore can double up as our truststore since it happens to contain the server cert by virtue of its certificate chain, and naturally it must trust the server to which it wishes to connect. If the client cert is CA-signed, we must not use its keystore as its truststore, otherwise it would trust any server with a cert signed by that CA, since the CA certificate must be in the keystore as the root of the key certificate chain.

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

Our server keystore can also double up as its truststore in this particular case, since naturally it contains the self-signed server cert (paired with its private key), and our client certs' CA cert is in fact this server cert.

If our server cert is CA-signed, then since the keystore must include its key certificate chain, it will include the CA root cert. Therefore if the keystore is misused as the trustore, then the server would trust <i>any</i> client cert signed by that CA.

<h4>Client certificate management</h4>

Clearly a certificate with a duplicate CN, impersonates the original certificate with that CN. So when issuing a client certificate, we must take care to ensure the uniqueness of the CN, and add the certificate or at least its unique identifier to a registry of some sort. 

If a certificate is signed but not recorded, or its record is deleted, our server is forever vulnerable to that rogue certificate. In order to review access, we clearly require a perfect record of all issued certificates. So we might record our signed certs into a keystore file as follows.
{{{
$ keytool -keystore server.issued.jks -importcert -alias evanx -file evanx.pem 
Certificate was added to keystore
}}}
where this is not a truststore per se, but just a database of issued certificates. 

Interestingly, in trying to avoid a truststore containing all our client certificates, we have nevertheless ended up with one! 

<h4>Self-signed client certificates</h4>

All told, given the risk of a rogue certificate, we recommend using self-signed client certificates which are explicitly imported into our server truststore, where can be reviewed. Any issued certificate which goes unrecorded or is given a duplicate identifier by mistake or on purpose, is a vulnerability.

Note that when using self-signed client certs (or CA-signed server certs), the server keystore must not be used as its truststore, since the keystore naturally contains the server certificate, and so a rogue certificate can be created by signing it with the server key, e.g. using <tt>keytool -gencert</tt>, as illustrated above. 

Similarly, when using CA-signed server certs, the server keystore contains the CA root key, and so must not be used as the truststore. Otherwise any client cert signed by that CA would trusted, rather than just the client certs we have specifically added to the truststore.

As a precaution, we might use an exclusive client trust manager, implemented as follows.
{{{
public class ExclusiveClientTrustManager implements X509TrustManager {
    X509TrustManager delegate;
    Map<String, X509Certificate> certificateMap = new HashMap();
    
    public ExclusiveClientTrustManager(KeyStore trustStore) 
        throws GeneralSecurityException {
        this.delegate = KeyStores.getX509TrustManager(trustStore);
        for (String alias: Collections.list(trustStore.aliases())) {
            certificateMap.put(alias, (X509Certificate) 
                    trustStore.getCertificate(alias));
        }
    }
    ...
}}}
where we build a map of the certificates in our truststore, and check these as follows.
{{{    
    private void checkTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        if (certs.length != 1) {
            throw new CertificateException("Invalid cert chain length");
        }
        X509Certificate trustedCertificate = certificateMap.get(
                getCN(certs[0].getSubjectDN()));
        if (trustedCertificate == null) {
            throw new CertificateException("Untrusted client certificate");            
        }
        if (!Arrays.equals(certs[0].getPublicKey().getEncoded(),
                trustedCertificate.getPublicKey().getEncoded())) {
            throw new CertificateException("Invalid client certificate");
        }
    }

    @Override
    public void checkClientTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        logger.debug("checkClientTrusted {}", certs[0].getSubjectDN().getName());
        checkTrusted(certs, authType);
        delegate.checkClientTrusted(certs, authType);
    }
}}}
where we only accept our self-signed client certificates i.e. the first cert in the chain sent by the peer.

<h4>Conclusion</h4>

We can sign client certificates using our server certificate, which is then our local CA root certificate. As such we should support certificate revocation. So we introduce a custom SSL trust manager to support a local revocation list. Naturally this is only useful is if we can configure our server to use it!

<img align="right" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

In this special case, we can use our keystore as our truststore, which we argue is a practice that should be prohibited ordinarily.

We discuss the risk of rogue certificates, and recommend using self-signed client certificates whenever possible, rather than a local CA as presented here.

<h4>Furthermore</h4>

We'll delve into the unit testing of our custom trust manager in a follow-up article. Thereafter, we might implement a local CA management tool that records issued certificates, a local CA server supporting standard CRLs, and perhaps even a web-based admin tool for these goodies.

<h4>Resources</h4>

You can browse the code for this exercise on <a href="https://code.google.com/p/vellum">code.google.com/vellum</a>.

<h4>Other reading</h4>

Also relating to Java crypto in this blog: <a href="https://weblogs.java.net/blog/evanx/archive/2013/01/24/password-salt">Password Salt</a> for secure passwords; and leveraging the <a href="https://weblogs.java.net/blog/evanx/archive/2012/11/07/google-authenticator-thus-enabled">Google Authenticator</a> mobile app for multi-factor authentication for your own sites.

